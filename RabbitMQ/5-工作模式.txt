# coding: utf-8
# @Time : 2021/6/6 11:47 上午 
# @Author : DB.Bruce Dong

1、工作队列（又名：任务队列）
    背后的主要思想是避免立即执行资源密集型任务而不得不等待它完成。
    相反，我们安排任务稍后完成。我们将一个任务封装 成一条消息并发送到队列中。
    在后台运行的工作进程将弹出任务并最终执行作业。当您运行许多工人时，任务将在他们之间共享。

2、循环调度
    使用任务队列的优势之一是能够轻松并行化工作。如果我们正在建立积压的工作，
    我们可以添加更多的工作人员，这样就可以轻松扩展。
    默认情况下，RabbitMQ 将按顺序将每条消息发送给下一个消费者。
    平均而言，每个消费者将获得相同数量的消息。这种分发消息的方式称为轮询。
3、消息确认
    完成一项任务可能需要几秒钟。您可能想知道，如果其中一个消费者开始了一项长期任务并且只完成了部分任务而死亡，
    会发生什么。使用我们当前的代码，一旦 RabbitMQ 将消息传递给消费者，它就会立即将其标记为删除。
    在这种情况下，如果你杀死一个工人，我们将丢失它刚刚处理的消息。
    我们还将丢失所有已分派给该特定工作人员但尚未处理的消息。
    但我们不想丢失任何任务。如果一个工人死了，我们希望将任务交付给另一个工人。
    为了确保消息永远不会丢失，RabbitMQ 支持 消息确认。消费者发回一个 ack(nowledgement)
    来告诉 RabbitMQ 一个特定的消息已经被接收、处理并且 RabbitMQ 可以自由地删除它。
    如果消费者在没有发送 ack 的情况下死亡（其通道关闭、连接关闭或 TCP 连接丢失），
    RabbitMQ 将理解消息未完全处理并将重新排队。如果有其他消费者同时在线，它会迅速将其重新交付给另一个消费者。
    这样您就可以确保不会丢失任何消息，即使工作人员偶尔会死亡。
    默认情况下启用手动消息确认。在前面的例子中，我们通过auto_ack=True 标志明确地关闭了它们。
    一旦我们完成了一项任务，是时候移除这个标志并向工作人员发送适当的确认了
4、消息持久性
    我们已经学会了如何确保即使消费者死亡，任务也不会丢失。但是如果RabbitMQ服务器停止，我们的任务仍然会丢失
    当 RabbitMQ 退出或崩溃时，它会忘记队列和消息，除非你告诉它不要。需要做两件事来确保消息不会丢失：
    我们需要将队列和消息都标记为持久的。
    首先，我们需要确保队列能够在 RabbitMQ 节点重启后继续存在。为此，我们需要将其声明为持久的：
    channel.queue_declare(queue='task_queue', durable=True)
    现在我们需要将我们的消息标记为持久的——通过提供一个值为2的delivery_mode属性。
    delivery_mode = 2 , # 使消息持久化-生产者设置
5、公平调度
    使用带有prefetch_count=1设置的Channel#basic_qos通道方法 。这使用basic.qos协议方法告诉 RabbitMQ
    一次不要给一个工人多个消息。或者，换句话说，在处理并确认前一条消息之前，不要向工作人员发送新消息。
    相反，它会将它分派给下一个不忙的工人
    channel.basic_qos(prefetch_count= 1 ) # 消费者设置





