1、事务
    可以执行多个命令，一组命令的集合；一个事务中的命令都会序列化，按顺序的执行，而不会被其他命令插入，不许加塞；
2、常用命令
    multi 标记一个事务块的开始
    discard 取消事务，放弃执行事务块内的所有命令
    exec 执行所有事务块内命令
    unwatch 取消watch命令对所有key的监视
    watch key 监视key，如谷歌事务执行前这些key被其他命令改动，事务被打断

3、正常执行实例：
    127.0.0.1:6379[1]> MULTI
    OK
    127.0.0.1:6379[1]> set k1 v1
    QUEUED
    127.0.0.1:6379[1]> set k2 v2
    QUEUED
    127.0.0.1:6379[1]> EXEC 执行  、 DISCARD 放弃
    1) OK
    2) OK

4、redis事务不是强一致性，事务中操作可以部分成
    127.0.0.1:6379[1]> MULTI
    OK
    127.0.0.1:6379[1]> incr k1
    QUEUED
    127.0.0.1:6379[1]> set k3 v3
    QUEUED
    127.0.0.1:6379[1]> set k4 v4
    QUEUED
    127.0.0.1:6379[1]> get k4
    QUEUED
    127.0.0.1:6379[1]> EXEC
    1) (error) ERR value is not an integer or out of range
    2) OK
    3) OK
    4) "v4"

5、悲观锁，乐观锁，CAS（check and set）
    悲观锁：（pessimistic lock）每次拿数据的时候都认为别人修改，所以拿数据的时候会上锁，这样别人拿这个数据就会block，
        很多关系型数据库都有这种机制，比如行锁，表锁，读锁，写锁，都是操作前先上锁；
    乐观锁：（optimistic lock）每次拿数据认为别人不会修改，所以不上锁，但是在更新前会判断下在此期间别人有没有更新，使用版本号机制，
        乐观锁适合读的应用类型，这样可以提供吞吐量；

6、watch监控
    先监控在开启multi,发现监控值变化，整个事务都会失败
    127.0.0.1:6379[1]> WATCH balance
    OK
    127.0.0.1:6379[1]> MULTI
    OK
    127.0.0.1:6379[1]> DECRBY balance 20
    QUEUED
    127.0.0.1:6379[1]> EXEC

7、unwatch
    127.0.0.1:6379[1]> WATCH balance
    OK
    127.0.0.1:6379[1]> get balance
    "1000"
    127.0.0.1:6379[1]> UNWATCH  取消监控
    OK
    127.0.0.1:6379[1]> MULTI
    OK
    127.0.0.1:6379[1]> set balance 9000
    QUEUED
    127.0.0.1:6379[1]> EXEC
    1) OK
8、3阶段
    开启：multi
    入队列，命令写入队列，等待执行
    执行：exec命令出发事务
9、3特性
    单独隔离操作：事务中命令按顺序执行，不会被其他客户端命令请求打断；
    没有隔离级别概念：也就是在事务提交前，都不会执行，只会放在队列中，也就不存在事务里查看有更新的情况；
    不保证原子性：redis同一事务中如果一条命令执行失败，其他后面的命令仍然执行，没有回滚；

10、
11、
12、
13、
14、
15、
16、
17、
18、
