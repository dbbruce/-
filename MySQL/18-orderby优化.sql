1、order by子句，尽量使用index方式排序，避免filesort方式排序；
    order by 语句使用索引最左前列，尽可能在索引列上排序；
    比如：index(c1,c2,c3)
    order by c1,c2,c3 最好

2、单路排序、双路排序
    1、双路排序
        mysql4.1前使用双路排序，扫描2次磁盘
        读取行指针和order by 列，对他们进行排序，然后扫描已经排好序的列表，按照列表中的值重新从列表中读取对应的数据输出；

    2、单路排序
        从磁盘读取查询需要的所有列，按照order by列在buffer对他们进行排序，然后扫描排序后的列表进行输出，
        他的效率更快一些，便面了第二次读取数据，并且把随机IO变成了顺序IO，但是它会使用更多的空间，因为它把每一行都保存在内存中。
        注意：如果sort_buffer比较小，单列排序，每次数据量都有限，反而比多路复用更慢；

3、提供order by的速度
    1、orderby是select * 是一个大忌，只需query需要的字段，这点非常重要，这里会影响
        1.1、当query的字段大小总和小于max_length_for_sort_data 而且排序字段不喜欢text|BOLB类型时，会用改进后的算法--单路排序；
        否则用老算法多路排序；
        1.2、两种算法的数据都有可能超出sort_buffer的容量，超出之后，会创建temp文件进行合并排序，导致多次IO，但用单路排序算法的分析会更大
        一些，索引要提供sort_buffer_size

    2、尝试提高sort_buffer_size
        不管哪个算法，提供这个参数都会提供效率，这个参数针对每个进程

    3、尝试提高 max_length_for_sort_data
        提高这个参数，会增加用改进算法的概率，但是如果设的太高，数据总容量超出sort_buffer_sizer的概率就增大，明显正在是高磁盘IO和低cpu使用率；

